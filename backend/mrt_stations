---
title: "MRT Stations Masterlist"
author: "Choo Choo Train"
date: "`r Sys.Date()`"
output: github_document
---

```{r setup, include=FALSE}

# Load required packages
library(tidyverse)   # Contains dplyr (data manipulation), tidyr (data tidying), tibble (data frame manipulation)
                     # ggplot2 (data visualisation), purrr (functional programming)
library(rvest)       # For HTML and XML web scraping
library(stringr)     # For string manipulation
library(jsonlite)    # For reading JSON data
library(geosphere)   # For Haversine distance
```

# COMPLETE MRT LIST
The following website from Property Review contains the full list of all 251 MRT and LRT station names and codes in Singapore. The 251 contains existing stations along with stations and MRT lines that are under construction, such as the upcoming TEL extensions, the Cross Island Line and the Jurong Regional Line. 

Our project is focused on scoring existing MRT stations based on their vulnerability to breakdowns and delays. After filtering and cleaning our dataset, we are left with 143 unique MRT stations. The `stations` dataframe itself contains 171 rows of data as it counts interchange stations as a separate observation with a different line and station code. There are 25 unique interchange stations, 3 of which (Dhoby Ghaut, Marina Bay, Outram Park) service 3 different MRT lines. The remaining 22 stations service 2 lines. 

## Property Review link
```{r}
mrtstaionlink <- "https://propertyreviewsg.com/complete-singapore-mrt-list-english-and-chinese-station-names/"
page <- read_html(mrtstaionlink)
```

### MRT station names and codes cleaning
The station code, station name and line name has been directly extracted from the Property Review website. These variables have been renamed to `station_code`, `stations` and `line`. 

Additional variables that have been added to the data include:
- `line_code`: which can be extracted from the first two alpha characters in `station_code` and adding an "L" (standing for "Line") at the end
- `line_number`: which can be extracted from the numeric digits in `station_code`, and describes the position of the station along the line (at the front, middle or end)
- `join_station`: a standardised `station_name` variable that can be used to join with other datasets
- `is_interchange`: An indicator variable with values 0 (not an interchange) and 1 (is an interchange), which is obtained by counting the number of occurrences of a station.

```{r}
names <- page %>% html_nodes("table") %>% .[[1]] %>% html_table %>%
  
  select(
    station_code = `Station Code`,
    stations = `MRT Station English Name`,
    line = `MRT Line English`) %>%
  
  # standardise string format
  mutate(line = gsub("-", " ", line)) %>%
  
  # add additional entries for stations with unconventional naming methods
  rbind(c("EW27",	"Boon Lay", "East West Line"),
        c("NE17", "Punggol", "North East Line"),
        c("EW1", "Pasir Ris",	"East West Line"),
        c("NE18", "Punggol Coast", "North East Line"),
        c("DT4", "Hume", "Downtown Line"),
        c("NS12", "Canberra", "North South Line"))%>%
  
  # filter for irrelevant entries
  filter(!str_detect(line, "LRT")) %>%  # remove rows where line contains "LRT" 
  filter(!str_detect(line, "Jurong Region Line")) %>%  # remove "Jurong Region Line" (Not yet built: commencement in 2027-2029)
  filter(!str_detect(line, "Cross Island Line")) %>% # remove "Cross Island Line" (Not yet built: commencement in 2030-2032)
  filter(!(stations %in% c("Mount Pleasant", "Marina South", "Founders' Memorial", "Bedok South", "Sungei Bedok"))) %>% ## underconstruction
  
  drop_na() %>%
  
  mutate(
    line_code = str_extract(station_code, "[A-Za-z]+") %>% paste0("L"),  # Extract line_code using station_code
    line_code = case_when(line_code == "CEL" ~ "CCL",                    # treat Circle Extension as Circle Line
                          TRUE ~ line_code),
    line = case_when(line == "Circle Line Extension" ~ "Circle Line",    # treat Circle Extension as Circle Line
                          TRUE ~ line),
    line_number = as.numeric(str_extract(station_code, "\\d+")),         # Extract line_number
    join_station = tolower(gsub(" ", "", stations))) %>%
  
  # each row is a unique mrt_code, so if station name appears more than once it is an interchange  
  group_by(join_station) %>%
  mutate(is_interchange = ifelse(n() > 1, 1, 0)) %>%
  ungroup() %>%
  arrange(line_code, line_number) 

```

We want to find indicate if the stations are underground or above ground, from our research we found that most lines except for NSL and EWL are built under ground. 

EWL is mostly above ground, except for [EW11] Lavender to [EW17] Tiong Bharu.
NSL is mostly above ground, except for [NS18] Braddell to [NS28] Marina South Pier.
Total: 43 stations above ground.

We have indicated the filled the column `is_above_ground` as such:
1: above ground, 0: under ground

```{r}
names <- names %>%
  mutate(
    is_above_ground = case_when(
      line_code =="NSL" & !between(line_number, 19, 27) ~ 1,  # If NS line & line number between 18-28, set to 1
      line_code =="EWL" & !between(line_number, 12, 16) ~ 1,  # If EW line & line number between 11-17, set to 1
      TRUE ~ 0))  # Otherwise, set to 0 (underground)
```

## Wikipedia MRT Line Characteristics
Next, our team found additional information on station and line characteristics from Wikipedia. The variables extracted from the web scrape as follows:
- `operator`: A character variable recording the MRT line's operator; SMRT Trains or SBS Transit
- `commencement`: The start date of operation for the MRT line.
- `line_age`: A numeric variable calculated as a difference between today's date and the commencement date. 
- `n_stations`: The number of stations along an MRT line.
- `length`: The length (in kilometers) of the MRT line.
- `cost`: The total cost of construction for the MRT line.
- `cost_per_km`: The cost of construction per kilometer.

```{r}
wiki_link = "https://en.wikipedia.org/wiki/Mass_Rapid_Transit_(Singapore)"
wiki_page = read_html(wiki_link)
```

```{r}
line_info <- wiki_page %>% html_nodes("table") %>% .[3] %>% html_table() %>% .[[1]] %>%
  
  filter(`Name and colour` != "Total:") %>% 
  
  rename(line = `Name and colour`,
         operator = Operator) %>%
  
  mutate(line = gsub("â€“", " ", line)) %>%    # standardise string format (remove dashes)
  
  mutate(line = case_when(
    `Commencement` == "7 November 1987" ~ "North South Line",  # fix a minor data entry error for North South Line in `line` column
    TRUE ~ line)) %>%                                          # Keep original value otherwise
  
  drop_na() %>%
  
  mutate(line_code = case_when(
           line == "North South Line" ~ "NSL",
           line == "East West Line" ~ "EWL",
           line == "Circle Line" ~ "CCL",
           line == "Downtown Line" ~ "DTL",
           line == "Thomson East Coast Line" ~ "TEL",
           line == "North East Line" ~ "NEL"),
         
         commencement = as.Date(Commencement, format="%d %B %Y"), 
         # line age with reference to commencement date
         line_age = as.numeric(difftime(Sys.Date(), commencement, units = "days")) %/% 365.25) %>%
  
  mutate(
    n_stations = as.numeric(str_remove_all(Stations, "\\[.*?\\]")),         # remove square brackets
    length = str_remove_all(Length, "\\[.*?\\]|\\(.*?\\)"),                 # remove square brackets and parentheses
    length = as.numeric(str_extract(length, "\\d+(\\.\\d+)?")),
    cost = str_remove_all(Cost, "\\[.*?\\]"),
    cost = as.numeric(str_extract(cost, "\\d+(\\.\\d+)?")),                 # in Billions
    cost_per_km = cost/length
    ) %>%
  
  # remove irrelevant columns
  select(-`Previous extension`, -`Next extension`, -Terminus, -`Control Centre`, -Stations, -Length, -Cost, -Commencement, -`Depot(s)`)

```

As the Wikipedia page does not contain information on the Changi Airport Branch Line, we have manually added their information.

```{r}
stations <- names %>% left_join(line_info) %>%
  mutate(                               # handle missing entries for CGL: Changi Airport and Expo stations
  operator = case_when(
    line_code == "CGL" ~ "SMRT Trains",
    TRUE ~ operator),
  commencement = case_when(
    line_code == "CGL" ~ ymd("2002-02-08"),
    TRUE ~ commencement),
  line_age = case_when(
    line_code == "CGL" ~ as.numeric(difftime(Sys.Date(), commencement, units = "days")) %/% 365.25,
    TRUE ~ line_age),
  n_stations = case_when(
    line_code == "CGL" ~ 2,
    TRUE ~ n_stations),
  length = case_when(
    station_code == "CG1" ~ 41.9, # use DTL
    station_code == "CG2" ~ 57.2, # use EWL
    TRUE ~ length),
  cost = case_when(
    station_code == "CG1" ~ 20.7, # use DTL
    station_code == "CG2" ~ 13.68, # use EWL
    TRUE ~ cost))
```

Save the final MRT Stations masterlist dataset
```{r}
write.csv(stations, file = "stations.csv")
```


## Visualisations
The following plot shows the number of stations along each line that are interchange stations. The plot shows that Circle line has the highest number of stations that are also interchange stations (12 stations). This is closely followed by Downtown Line (11 stations). Changi Airport Branch Line has the least number of interchange stations (1 station). 

```{r}
line_colours <- c(
  CGL = "darkolivegreen2",
  CCL = "goldenrod2",
  DTL = "blue3",
  EWL = "forestgreen",
  NEL = "purple3",
  NSL = "red3",
  TEL = "chocolate4")

line_labels <- c(
  CGL = "Changi Airport Branch Line",
  CCL = "Circle Line",
  DTL = "Downtown Line",
  EWL = "East West Line",
  NEL = "North East Line",
  NSL = "North South Line",
  TEL = "Thomson East Coast Line")

interchange_plot <- stations %>% 
  filter(is_interchange > 0) %>% 
  count(line, line_code) %>% 
  arrange(desc(n)) %>%
  
  ggplot(aes(x = reorder(line_code, -n), y = n, fill = line_code)) +
  geom_col() +
  geom_text(aes(label = n), vjust = -0.5, size = 4) + 
  scale_fill_manual(values = line_colours, labels = line_labels) +
  labs(x = "MRT Line Code",
       y = "Number of Interchange Stations", 
       fill = "MRT Line Name", 
       title = "Distribution of Interchange Stations along MRT Lines") +
  theme_minimal()

interchange_plot
```

However, when looking at the proportion of interchange stations amongst the total number of stations in the line, our data looks much different. Changi Airport Branch Line has the highest proportion of interchange stations, that being 1 out of a total of 2 stations on its line (50%). This is followed by Circle Line with 40% of stations on its line being interchanges. 

Our team considers interchange stations to be better connected compared to non-interchange stations, and thus they will receive a higher weighting for its Connectivity scoring. For Vulnerability, we believe this characteristic will not be significant in determining the stations susceptibility to faults or delays, and this is confirmed in our model.

```{r}
interchange_prop_plot <- stations %>% 
  filter(is_interchange > 0) %>% 
  count(line, line_code, n_stations) %>%
  mutate(n_prop = round(n/n_stations, 3)) %>%
  arrange(desc(n_prop)) %>%
  
  ggplot(aes(x = reorder(line_code, -n_prop), y = n_prop, fill = line_code)) +
  geom_col() +
  geom_text(aes(label = n_prop), vjust = -0.5, size = 4) + 
  scale_fill_manual(values = line_colours, labels = line_labels) +
  labs(x = "MRT Line Code", 
       y = "Proportion of Interchange Stations", 
       fill = "MRT Line Name", 
       title = "Proportion of Interchange Stations along MRT Lines") +
  theme_minimal()

interchange_prop_plot
```



## Ridership Data
Our team collected data on ridership volume to observe any correlation between service disruptions and higher passenger volume. Higher ridership volume leads to more stress on transport infrastructure as train interval timings are usually modified (shortened) to accommodate more passengers. Our data was sourced from ..., and it contains information on .... The variables extracted from the dataset as follows:
- `is_peak`: An indicator variable based on Singapore's weekday peak hour definition; peak is between 6.00am-9.00am and 4.00pm-8.00pm (not inclusive), and these are indicated with 1. Off-peak timings are indicated with 0.
- `day_type`: A factor variable with 2 levels; WEEKDAY and WEEKEND/HOLIDAY.
- `n_riders`: The ridership volume (number of riders)

```{r}
ridership_path_20232024 = "transport_node_train_20232024collated.csv"
df2024_2023 <- read.csv(ridership_path_20232024)
head(df2024_2023)

# Aggregate average number of riders for weekday and weekend
df_avg_riders <- df2024_2023 %>%
  group_by(TIME_PER_HOUR, DAY_TYPE) %>%
  summarise(AVG_RIDERS = mean(TOTAL_TAP_IN_VOLUME + TOTAL_TAP_OUT_VOLUME, na.rm = TRUE)) %>%
  ungroup()

# Aggregate average number of riders for weekday and weekend
df_avg_riders_clean <- df2024_2023 %>%
  group_by(YEAR_MONTH,TIME_PER_HOUR, DAY_TYPE, PT_CODE) %>%
  summarise(AVG_RIDERS = round(mean(TOTAL_TAP_IN_VOLUME + TOTAL_TAP_OUT_VOLUME, na.rm = TRUE))) %>%
  ungroup() %>% 
  mutate(is_peak = case_when(TIME_PER_HOUR > 6 & TIME_PER_HOUR < 9 & DAY_TYPE == "WEEKDAY" ~ 1,
                             TIME_PER_HOUR > 16 & TIME_PER_HOUR < 20 & DAY_TYPE == "WEEKDAY" ~ 1,  
                             TRUE ~ 0),
         PT_CODE = sub("/.*", "", PT_CODE),
         # year = year(ym(YEAR_MONTH)),
         month = month(ym(YEAR_MONTH))) %>%
  # since we don't have values for each line in interchange stations we will just drop values behind / for ease of join
  rename("station_code" = "PT_CODE", "hour" = "TIME_PER_HOUR", "n_riders" = "AVG_RIDERS", "day_type" = "DAY_TYPE")

```
Save ridership volume for plotting
```{r}
write.csv(df_avg_riders, file = "df_avg_riders.csv")
```

Join the `stations` MRT Stations masterlist with the ridership data.
```{r}
stations_ridership <- stations %>%
  left_join(df_avg_riders_clean, by = "station_code") 

missing_riders <- stations_ridership %>% filter(is.na(n_riders)) %>%
  left_join(stations_ridership, by = c("stations", "join_station")) %>%
  mutate(n_riders = coalesce(n_riders.x, n_riders.y),
         YEAR_MONTH = coalesce(YEAR_MONTH.x, YEAR_MONTH.y),
         day_type = coalesce(day_type.x, day_type.y),
         is_peak = coalesce(is_peak.x, is_peak.y),
         month = coalesce(month.x, month.y)) %>%
  select(station_code = station_code.x, stations, line = line.x, line_code = line_code.x, line_number = line_number.x,
         join_station, is_interchange = is_interchange.x, is_above_ground = is_above_ground.x, operator = operator.x,
         commencement = commencement.x, line_age = line_age.x, n_stations = n_stations.x, length = length.x,
         cost = cost.x, cost_per_km = cost_per_km.x, YEAR_MONTH, day, day_type, is_peak, month, n_riders)

stations_ridership_filled <- stations_ridership %>%
  left_join(missing_riders, by = "station_code") %>%
  mutate(across(ends_with(".x"), 
                ~ coalesce(.x, get(sub(".x$", ".y", cur_column()))), 
                .names = "{sub('.x$', '', .col)}")) %>%
  select(-ends_with(".x"), -ends_with(".y"))

#length(unique(stations_ridership_filled$stations))

# RIDERSHIP VOLUME WEIGHTS: could make it more accurate by taking the sum of all ridership and use the ratio of the total line
# ridership was the weight for the line
```
Save MRT stations with ridership data
```{r}
write.csv(stations_ridership_filled, file = "stations_ridership_filled.csv") 
```

### Visualisation
The following graph shows the ridership volume during Weekdays and Weekend / Public holidays.

The plot is bimodal for Weekdays, with two peaks at 8am and 6pm, indicating the height of the morning and evening peaks respectively. These are the hours high stress on MRT systems. 

For Weekdays / Public Holidays, the graph is generally uniform. Passenger volume steadily increases throughout the day from 5am, reaching its highest volume at 5pm and 6pm, which coincide with the dinner crowd. 

No data points are recorded between 1am to 4am as the MRT is closed for operation during those hours. 
```{r}
df_avg_riders <- read.csv("df_avg_riders.csv")

ggplot(df_avg_riders, aes(x = TIME_PER_HOUR, y = AVG_RIDERS, color = DAY_TYPE)) +
  geom_line(size = 1.2) +  # Line plot
  geom_point(size = 2) +   # Add points for clarity
  labs(title = "Average Number of Riders by Hour (Weekday vs Weekend)",
       x = "Hour of the Day",
       y = "Average Number of Riders",
       color = "Day Type") +
  theme_minimal() +
  scale_x_continuous(breaks = seq(0, 23, by = 1)) +  # Show all hours
  scale_color_manual(values = c("WEEKDAY" = "blue", "WEEKENDS/HOLIDAY" = "red")) 
```


## Rainfall Data
Our team observed that MRT service disruptions are more frequent during periods of bad weather. As such, we decided to collect data on Singapore's rainfall patterns to observe if weather conditions could help us predict potential service disruptions, and see if certain MRT stations are more prone to breakdowns due to bad weather. 

Our data was obtained using OneMap API coordinates to find the nearest weather device and its respective rainfall in millimeters for a particular day .... 

(for your ref Ashley, I changed the file_path2 name so it looks nicer, here is your original: "C:/Users/ashle/Desktop/School/Y3S2/dse3101/Project/Data set/station_data.json")
```{r}
file_path2 <- "station_data.json"
data3 <- fromJSON(file_path2)
station_data <- data3$data[[1]] %>% unnest(location)
```

("C:/Users/ashle/Desktop/School/Y3S2/dse3101/Project/Data set/OneMap API pull/mrt_stations.csv")
```{r}
mrt_station_coordinates_filepath = "mrt_stations.csv"
mrt_station_coordinates <- read.csv(mrt_station_coordinates_filepath)


mrt_data <- mrt_station_coordinates %>%
  
  # Extract MRT or LRT station names
  mutate(Station_Name = tolower(str_remove_all(building, " MRT STATION| \\(.*\\)"))) %>% 
  
  group_by(Station_Name) %>%
  
  summarise(
    # there are instances whereby different mrt stations have different coordinates so we take the central coordinate for simplicity
    longitude = mean(longitude, na.rm = TRUE), 
    latitude = mean(latitude, na.rm = TRUE)) %>%
  
  select(Station_Name, longitude, latitude) 

```

```{r}

# Define a function to find the closest device for a given MRT station
find_closest_device <- function(mrt_longitude, mrt_latitude, station_data) {
  distance <- Inf
  closest_device_id <- NA
  
  # Loop through each device and compute the distance
  for (station in station_data$id) {
    current_device_data <- station_data[station_data$id == station, ]
    station_longitude <- current_device_data$longitude
    station_latitude <- current_device_data$latitude
    mrt_point <- c(mrt_longitude, mrt_latitude)
    weather_station_point <- c(station_longitude, station_latitude)
    new_distance <- distHaversine(mrt_point, weather_station_point)
    
    # Update the closest device if a smaller distance is found
    if (new_distance < distance) {
      distance <- new_distance
      closest_device_id <- station  # Store just the device ID
    }
  }
  
  return(closest_device_id)  # Return only the ID of the closest device
}

mrt_data <- mrt_data %>%
  rowwise() %>%
  mutate(closest_device = find_closest_device(longitude, latitude, station_data)) %>%
  ungroup() %>%
  select(Station_Name, closest_device) %>%
  mutate(
    Station_Name = gsub(" MRT STATION", "", Station_Name),
    Station_Name = gsub(" ", "", Station_Name)
  ) 
distinct_mrt <- names %>%
  select(join_station, stations) %>%
  distinct()
allocated_mrt_station <- left_join(distinct_mrt, mrt_data, by = c("join_station" = "Station_Name")) %>% 
  select(stations, join_station, closest_device)

```

("C:/Users/ashle/Desktop/School/Y3S2/dse3101/Project/Data set/rainfall_data.json")
```{r}
# Define file path
file_path <- "rainfall_data.json"

# Read JSON file into R
data <- fromJSON(file_path)

rain_falldf <- data[2][1] %>% 
  unnest(cols = c(data)) %>% 
  unnest(cols = c(data))%>%
  mutate(
    #year = year(timestamp),
    month = month(timestamp)
  ) %>%
  group_by(month, stationId) %>%
  summarise(`average_monthly_rainfall(mm)` = replace_na(mean(value, na.rm = TRUE))) %>%
  ungroup

 
rainfalldf <-left_join(allocated_mrt_station,rain_falldf,  by = c("closest_device" = "stationId"), relationship = "many-to-many")
```

Save rainfall data
```{r}
save(rainfalldf, file = "mrt_rainfalldf_monthly.RData")
```


Join the updated MRT Stations masterlist with the rainfall data. 
```{r}
load("mrt_rainfalldf_monthly.RData") # loads in as `rainfalldf`

full_stations <- stations_ridership_filled %>%
  left_join(rainfalldf, by = c("month", "join_station", "stations"))

# length(unique(full_stations$stations))
```
Note (remove later): if inner_joined used, we lose 2 stations: Bukit Panjang and Hume.


Save the finalised MRT Stations masterlist (with ridership and rainfall)
```{r}
write.csv(full_stations, file = "full_stations.csv")
```



